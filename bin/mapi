#!/usr/bin/env bash
set -Eeuo pipefail
[[ "${MAPI_DEBUG:-0}" == "1" ]] && set -x

# ------------------------------------------------------------
# Locate repo root and tools
# ------------------------------------------------------------
THIS="$(readlink -f "$0" 2>/dev/null || python3 -c 'import os,sys; print(os.path.realpath(sys.argv[1]))' "$0")"

# Prefer an explicit MalariAPI root under $HOME if it exists
if [[ -z "${REPO_ROOT:-}" ]]; then
  if [[ -d "$HOME/MalariAPI" ]]; then
    REPO_ROOT="$HOME/MalariAPI"
  else
    # Fallback: infer from script location (supports dev checkouts)
    REPO_ROOT="$(cd "$(dirname "$THIS")/.." && pwd)"
  fi
fi

# MAPI_ROOT is the “logical” root; can override via env or .mapi.env
MAPI_ROOT="${MAPI_ROOT:-$REPO_ROOT}"
TOOLS_DIR="$MAPI_ROOT/tools"
CFG_JSON="$TOOLS_DIR/hpc_config.json"

# Load installer exports if present
if      [ -f "$MAPI_ROOT/bin/.mapi.env" ]; then
  # shellcheck source=/dev/null
  . "$MAPI_ROOT/bin/.mapi.env"
elif    [ -f "$MAPI_ROOT/bin/mapi.env" ]; then  # back-compat
  # shellcheck source=/dev/null
  . "$MAPI_ROOT/bin/mapi.env"
fi

have_jq() { command -v jq >/dev/null 2>&1; }

# ------------------------------------------------------------
# Conda root resolver (for local modules/pipelines/packages)
# ------------------------------------------------------------
resolve_conda_root() {
  if [[ -n "${MAPI_CONDA_ROOT:-}" && -d "$MAPI_CONDA_ROOT" ]]; then
    printf '%s\n' "$MAPI_CONDA_ROOT"
    return 0
  fi
  if [[ -d "$MAPI_ROOT/tools/miniconda3" ]]; then
    printf '%s\n' "$MAPI_ROOT/tools/miniconda3"
    return 0
  fi
  # Fallback: try to infer from "conda" on PATH
  if command -v conda >/dev/null 2>&1; then
    local c
    c="$(command -v conda)"
    printf '%s\n' "$(cd "$(dirname "$c")/.." && pwd)"
    return 0
  fi
  return 1
}

# Make sure CONDA_ROOT/PATH set for module/pipeline/package runs
if CONDA_ROOT="$(resolve_conda_root)"; then
  export PATH="$CONDA_ROOT/bin:$PATH"
  export CONDA_ENVS_DIRS="$MAPI_ROOT/envs"
fi

# ------------------------------------------------------------
# Shared layout for module/pipeline/package/script/tools
# ------------------------------------------------------------
BIN_DIR="$MAPI_ROOT/bin"
MOD_DIR="$BIN_DIR/modules"

# ------------------------------------------------------------
# MSF (MAPI Sample Folder) detection
# ------------------------------------------------------------
detect_msf() {
  local dir="$PWD" base sample
  while [[ "$dir" != "/" && -n "$dir" ]]; do
    base="$(basename "$dir")"
    if [[ "$base" == mapi-* ]]; then
      sample="${base#mapi-}"
      export MAPI_SAMPLE_ROOT="$dir"
      export MAPI_SAMPLE_NAME="$sample"
      export MAPI_SAMPLE_OUT="$dir/$sample-output"
      return 0
    fi
    dir="$(dirname "$dir")"
  done
  return 1
}

detect_msf || true

# ------------------------------------------------------------
# YAML helpers (for env + listing)
# ------------------------------------------------------------
find_module_yaml() {
  local n="$1"
  local candidates=(
    "$BIN_DIR/modules/yaml/$n.yml"
    "$BIN_DIR/modules/yaml/$n.yaml"
  )
  local c
  for c in "${candidates[@]}"; do
    [[ -f "$c" ]] && { echo "$c"; return 0; }
  done
  return 1
}

get_env_name_from_yaml() {
  local y="$1"
  local val
  val="$(grep -E '^[[:space:]]*env_name:' "$y" 2>/dev/null | head -n1 | sed 's/^[[:space:]]*env_name:[[:space:]]*//')" || true
  if [[ -n "$val" ]]; then
    printf '%s\n' "$val"
    return 0
  fi
  val="$(grep -E '^[[:space:]]*name:' "$y" 2>/dev/null | head -n1 | sed 's/^[[:space:]]*name:[[:space:]]*//')" || true
  [[ -n "$val" ]] && printf '%s\n' "$val"
}


# ------------------------------------------------------------
# Listing helpers (ignore hidden)
# ------------------------------------------------------------
list_items() {
  case "$1" in
    modules)
      [[ -d "$MOD_DIR" ]] && \
        find "$MOD_DIR" -maxdepth 1 -type f -name '*.sh' ! -name '.*' -printf '%f\n' 2>/dev/null \
        | sed 's/\.sh$//' | sort || true
      ;;
    tools)
      [[ -d "$TOOLS_DIR" ]] && \
        find "$TOOLS_DIR" -maxdepth 1 -type f \( -name '*.sh' -o -name '*.py' \) ! -name '.*' -printf '%f\n' 2>/dev/null \
        | sed -E 's/\.(sh|py)$//' | sort || true
      ;;
    *)
      echo "unknown type: $1" >&2; return 2;;
  esac
}

# ------------------------------------------------------------
# Header ENV: parser (primary/fallback)
# ------------------------------------------------------------
_read_env_from_header() {
  local script="$1"
  local header section="" line val primary="" fallback=""

  header="$(
    awk '/^# MAPI_META_BEGIN/{flag=1;next} /^# MAPI_META_END/{flag=0} flag{print}' "$script" 2>/dev/null \
      || true
  )"
  [[ -z "$header" ]] && { printf '\n\n'; return 0; }

  while IFS= read -r line; do
    # Strip leading "#"/"# " and whitespace
    line="${line#\# }"
    line="${line#\#}"
    line="${line#"${line%%[![:space:]]*}"}"
    line="${line%"${line##*[![:space:]]}"}"

    case "$line" in
      ENV:*)
        section="ENV"
        continue
        ;;
      NAME:*|SUMMARY:*|OUTPUTS:*|OPTIONS:*|RESOURCES:*|"")
        # Leaving ENV section
        [[ "$section" == "ENV" ]] && break
        ;;
    esac

    if [[ "$section" == "ENV" ]]; then
      case "$line" in
        primary:*)
          val="${line#primary:}"
          val="${val#"${val%%[![:space:]]*}"}"
          val="${val%"${val##*[![:space:]]}"}"
          primary="$val"
          ;;
        fallback:*)
          val="${line#fallback:}"
          val="${val#"${val%%[![:space:]]*}"}"
          val="${val%"${val##*[![:space:]]}"}"
          fallback="$val"
          ;;
      esac
    fi
  done <<< "$header"

  printf '%s\n' "$primary"
  printf '%s\n' "$fallback"
}

# ------------------------------------------------------------
# Env selection helper with header+YAML+default
# ------------------------------------------------------------
_choose_env_with_fallback() {
  # args: kind name script_path yaml_kind [meta_for_package]
  local kind="$1"; shift
  local name="$1"; shift
  local script="$1"; shift
  local yaml_kind="$1"; shift || true
  local meta="${1:-}"

  local primary="" fallback="" header_primary="" header_fallback=""
  local yaml_env=""

  # 1) Try header ENV for modules/pipelines/packages that have it
  if [[ -f "$script" ]]; then
    header_primary="$(_read_env_from_header "$script" | sed -n '1p')"
    header_fallback="$(_read_env_from_header "$script" | sed -n '2p')"
  fi

  # 2) YAML env_name as legacy/secondary
  case "$yaml_kind" in
    module)
      [[ -z "$meta" ]] && meta="$(find_module_yaml "$name" 2>/dev/null || true)"
      ;;
    pipeline)
      [[ -z "$meta" ]] && meta="$(find_pipeline_yaml "$name" 2>/dev/null || true)"
      ;;
    package)
      # meta passed in explicitly
      ;;
  esac

  if [[ -n "$meta" && -f "$meta" ]]; then
    yaml_env="$(get_env_name_from_yaml "$meta" 2>/dev/null || true)"
  fi

  # Decide primary/fallback env names
  if [[ -n "$header_primary" ]]; then
    primary="$header_primary"
    [[ -n "$header_fallback" ]] && fallback="$header_fallback"
  elif [[ -n "$yaml_env" ]]; then
    primary="$yaml_env"
  fi

  # Final fallback chain
  [[ -z "$primary" ]] && primary="default"
  [[ -z "$fallback" ]] && fallback="default"

  local prefix
  prefix="$MAPI_ROOT/envs/$primary"
  if [[ ! -d "$prefix" ]]; then
    echo "[mapi] WARNING: env '$primary' for $kind '$name' not found at $prefix; trying fallback '$fallback'." >&2
    prefix="$MAPI_ROOT/envs/$fallback"
    if [[ ! -d "$prefix" ]]; then
      echo "[mapi] WARNING: fallback env '$fallback' for $kind '$name' not found at $prefix; trying 'default'." >&2
      primary="default"
      prefix="$MAPI_ROOT/envs/default"
      if [[ ! -d "$prefix" ]]; then
        echo "[mapi] ERROR: default env not found at $prefix. Please install it (tools/install_envs --only default)." >&2
        return 3
      fi
    fi
  fi

  echo "[mapi] Running $kind '$name' in environment '$primary'." >&2
  printf '%s\n' "$prefix"
}

# ------------------------------------------------------------
# Module/pipeline/package/script/tools runner
# ------------------------------------------------------------
run_item() {
  local t="$1"; shift || true
  local name="${1:-}"; [[ -n "$name" ]] && shift || true

  case "$t" in
    modules)
      local entry="$MOD_DIR/$name.sh"
      [[ -x "$entry" ]] || { echo "mapi: module not found/executable: $entry" >&2; exit 4; }

      local prefix
      prefix="$(_choose_env_with_fallback module "$name" "$entry" module)" || exit $?

      export MAPI_REPO_ROOT="$MAPI_ROOT"
      export MAPI_MODULE_YAML="$(find_module_yaml "$name" 2>/dev/null || true)"

      # If we're in an MSF, gently suggest OUTDIR to modules via env
      if [[ -n "${MAPI_SAMPLE_OUT:-}" ]]; then
        export OUTDIR="${OUTDIR:-$MAPI_SAMPLE_OUT}"
      fi

      exec conda run -p "$prefix" bash "$entry" "$@"
      ;;

    tools)
      local sh="$TOOLS_DIR/$name.sh"
      local py="$TOOLS_DIR/$name.py"
      if [[ -f "$sh" && "$(basename "$sh")" != .* ]]; then
        exec bash "$sh" "$@"
      elif [[ -f "$py" && "$(basename "$py")" != .* ]]; then
        exec python3 "$py" "$@"
      else
        echo "mapi: tool not found: $name (looked for $sh or $py)" >&2
        exit 4
      fi
      ;;

    *)
      echo "mapi: unknown type '$t'" >&2
      exit 2
      ;;
  esac
}

# ------------------------------------------------------------
# HPC tag expander for args ([scratch], [home])
# ------------------------------------------------------------
_expand_hpc_args() {
  local hpc="$1"; shift
  local -a out=()
  local host home_root scratch_root

  # Prefer env exports from installer
  host="${MAPI_REMOTE_HOST:-}"
  home_root="${REMOTE_MAPI_HOME:-}"
  scratch_root="${REMOTE_MAPI_SCRATCH:-}"

  # Fill from JSON if missing
  if { [[ -z "$host" || -z "$home_root" || -z "$scratch_root" ]] && [[ -f "$CFG_JSON" ]] && have_jq; }; then
    host="${host:-$(jq -r --arg h "$hpc" '.clusters[$h].host // empty' "$CFG_JSON")}"
    home_root="${home_root:-$(jq -r --arg h "$hpc" '.clusters[$h].home_root // empty' "$CFG_JSON")}"
    scratch_root="${scratch_root:-$(jq -r --arg h "$hpc" '.clusters[$h].scratch_root // empty' "$CFG_JSON")}"
  fi

  local arg sub
  for arg in "$@"; do
    case "$arg" in
      "[scratch]"|"[scratch]/")
        if [[ -n "$scratch_root" ]]; then
          out+=("$scratch_root/scratch")
        else
          out+=("$arg")
        fi
        ;;
      "[scratch]"/*)
        if [[ -n "$scratch_root" ]]; then
          sub="${arg#\[scratch]/}"
          out+=("$scratch_root/scratch/$sub")
        else
          out+=("$arg")
        fi
        ;;
      "[home]"|"[home]/")
        if [[ -n "$home_root" ]]; then
          out+=("$home_root")
        else
          out+=("$arg")
        fi
        ;;
      "[home]"/*)
        if [[ -n "$home_root" ]]; then
          sub="${arg#\[home]/}"
          out+=("$home_root/$sub")
        else
          out+=("$arg")
        fi
        ;;
      *)
        out+=("$arg")
        ;;
    esac
  done

  printf '%s\0' "${out[@]}"
}

# ------------------------------------------------------------
# Help
# ------------------------------------------------------------
print_global_help() {
  cat <<EOF
mapi: MalariAPI CLI

HPC usage:
  mapi <hpc-name> <command> [args...]
    e.g. mapi rivanna submit --cmd "echo hi > [scratch]/test.out"

Module/pipeline/package usage:
  mapi modules
  mapi modules <name> [args...]
  mapi tools
  mapi tools <name> [args...]

Available HPCs, or other systems (tools/* directories):
EOF

  if [[ -d "$TOOLS_DIR" ]]; then
    local d bn
    for d in "$TOOLS_DIR"/*; do
      [[ -d "$d" ]] || continue
      bn="$(basename "$d")"
      case "$bn" in
        base|yaml|misc|templates|hpc_templates|scripts|bin|_*|miniconda3)
          continue
          ;;
      esac
      echo "  - $bn"
    done
  fi

  echo
  echo "Discovered (hidden entries suppressed):"
  echo "  modules  :";   list_items modules   | sed 's/^/    - /' || true
  echo "  tools    :";   list_items tools     | sed 's/^/    - /' || true
}

# ------------------------------------------------------------
# Main router
# ------------------------------------------------------------
if [[ $# -eq 0 || "$1" == "--help" || "$1" == "-h" ]]; then
  print_global_help
  exit 0
fi

# Case A (message): "mapi <subdir in /tools>" → list its tools
if [[ $# -eq 1 && -d "$TOOLS_DIR/$1" ]]; then
  case "$1" in
    base|yaml|misc|templates|hpc_templates|scripts|bin|_*|miniconda3)
      ;; # fall through to unknown command
    *)
      echo "'$1' tools:"
      for f in "$TOOLS_DIR/$1"/*; do
        [[ -x "$f" ]] || continue
        bn="$(basename "$f")"
        echo "  - $bn"
      done
      exit 0
      ;;
  esac
fi

# Case B (runner): "mapi <hpc> <cmd> ..." → HPC dispatch
if [[ $# -ge 2 && -d "$TOOLS_DIR/$1" && -x "$TOOLS_DIR/$1/$2" ]]; then
  _mapi_hpc="$1"
  _mapi_cmd="$2"
  shift 2

  # No remaining args → just run the HPC tool as-is
  if [[ $# -eq 0 ]]; then
    exec "$TOOLS_DIR/$_mapi_hpc/$_mapi_cmd"
  fi

  # Otherwise expand [scratch]/[home] tokens in the remaining args
  mapfile -d '' _expanded < <(_expand_hpc_args "$_mapi_hpc" "$@")
  exec "$TOOLS_DIR/$_mapi_hpc/$_mapi_cmd" "${_expanded[@]}"
fi

# Case D: "mapi tools <name> ..." / "mapi modules <name> ..." / etc.
case "${1:-}" in
  modules)
    t="$1"; shift || true
    if [[ $# -eq 0 ]]; then
      list_items "$t"
      exit 0
    else
      run_item "$t" "$@"
    fi
    ;;
  tools)
    t="$1"; shift || true

    # No subcommand → list tool groups
    if [[ $# -eq 0 ]]; then
      list_items "$t"
      exit 0
    fi

    tool="$1"; shift || true

    # Validate tool exists and is executable
    if [[ -x "$TOOLS_DIR/$tool" ]]; then
      exec "$TOOLS_DIR/$tool" "$@"
    fi

    echo "mapi tools: unknown tool '$tool'" >&2
    exit 2
    ;;
esac

# Fallback
echo "mapi: unknown command. Run 'mapi --help'." >&2
exit 2

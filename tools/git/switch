#!/usr/bin/env bash
set -Eeuo pipefail
[[ "${MAPI_DEBUG:-0}" == "1" ]] && set -x

ORIGIN_SPEC=""
UPSTREAM_SPEC=""
REPO_NAME="${REPO_NAME:-MalariAPI}"

# ------------------------------------------------------------
# Parse args
# ------------------------------------------------------------
while (( "$#" )); do
  case "$1" in
    --origin)
      ORIGIN_SPEC="$2"
      shift 2
      ;;
    --upstream)
      UPSTREAM_SPEC="$2"
      shift 2
      ;;
    --repo-name)
      REPO_NAME="$2"
      shift 2
      ;;
    --help|-h)
      cat <<EOF
Usage: mapi git switch [--origin <user|url>] [--upstream <user|url>] [--repo-name NAME]

Without arguments:
  - Prints the current git remotes and exits.

With --origin:
  - Changes (or creates) the 'origin' remote.
  - If value looks like a full URL (contains ':' or 'github.com' or starts with http),
    it is used as-is.
  - Otherwise it is treated as a GitHub username and expanded to:
        git@github.com:<user>/<repo-name>.git
    where <repo-name> defaults to '${REPO_NAME}' (override with --repo-name).

With --upstream:
  - Same behavior as --origin, but for the 'upstream' remote.

Examples:
  # Just see what origin/upstream are now
  mapi git switch

  # Point origin to your fork (ssh form inferred)
  mapi git switch --origin A-Crow-Nowhere

  # Point upstream to canonical MAPI repo (explicit URL)
  mapi git switch --upstream git@github.com:A-Crow-Nowhere/MalariAPI.git

  # Work with a differently named repo
  mapi git switch --origin someuser --repo-name SoftMAPI
EOF
      exit 0
      ;;
    *)
      echo "[git-switch] unknown option: $1" >&2
      exit 1
      ;;
  esac
done

# ------------------------------------------------------------
# Resolve MAPI root and verify repo
# ------------------------------------------------------------
MAPI_ROOT="${MAPI_ROOT:-$(cd "$(dirname "$0")/../.." && pwd)}"
cd "$MAPI_ROOT"

echo "[git-switch] MAPI_ROOT=$MAPI_ROOT"
if ! git rev-parse --is-inside-work-tree >/dev/null 2>&1; then
  echo "[git-switch] ERROR: $MAPI_ROOT is not a git repository."
  exit 1
fi

# Helper: show current remotes
show_remotes() {
  echo "[git-switch] current remotes:"
  git remote -v || true
}

# If no args: just show remotes and exit
if [[ -z "$ORIGIN_SPEC$UPSTREAM_SPEC" ]]; then
  show_remotes
  exit 0
fi

# ------------------------------------------------------------
# Helper: resolve a spec into a URL
# ------------------------------------------------------------
resolve_url() {
  local spec="$1"
  local repo="$2"
  local url=""

  # Looks like a full URL?
  if [[ "$spec" == http://* || "$spec" == https://* || "$spec" == *:* || "$spec" == *github.com* ]]; then
    url="$spec"
  else
    # Treat as GitHub username
    url="git@github.com:${spec}/${repo}.git"
  fi

  printf '%s\n' "$url"
}

# ------------------------------------------------------------
# Update origin if requested
# ------------------------------------------------------------
if [[ -n "$ORIGIN_SPEC" ]]; then
  NEW_ORIGIN_URL="$(resolve_url "$ORIGIN_SPEC" "$REPO_NAME")"
  echo "[git-switch] setting origin -> $NEW_ORIGIN_URL"

  if git remote | grep -qx origin; then
    git remote set-url origin "$NEW_ORIGIN_URL"
  else
    git remote add origin "$NEW_ORIGIN_URL"
  fi
fi

# ------------------------------------------------------------
# Update upstream if requested
# ------------------------------------------------------------
if [[ -n "$UPSTREAM_SPEC" ]]; then
  NEW_UPSTREAM_URL="$(resolve_url "$UPSTREAM_SPEC" "$REPO_NAME")"
  echo "[git-switch] setting upstream -> $NEW_UPSTREAM_URL"

  if git remote | grep -qx upstream; then
    git remote set-url upstream "$NEW_UPSTREAM_URL"
  else
    git remote add upstream "$NEW_UPSTREAM_URL"
  fi
fi

echo "[git-switch] updated remotes:"
show_remotes
